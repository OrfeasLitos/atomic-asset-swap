#include <obliv.oh>
#include <stdio.h>
#include <assert.h>
#include <openssl/sha.h>

#include "../obliv-c/test/oblivc/common/util.h"
#include "asset-swap.h"
#include "aes.h"

typedef obliv unsigned char obl_char;

unsigned char *good_secret = "1234567890abcdefghijklmnopqrstu";
unsigned char *bad_secret  = "fake_secret_to_baddies_like_you";

// TODO: give asset_cipher to both parties as cmd argument
// to avoid sending them obliviously with ocBroadcast()

void asset_swap(void* vargs) {
  ProtocolIO *args = (ProtocolIO*) vargs;

  size_t asset_cipher_size = ocBroadcastInt(args->asset_cipher_size, BUYER);
  size_t asset_plain_size = ocBroadcastInt(args->asset_plain_size, SELLER);

  obl_char expected_asset_cipher[MAX_ASSET_CIPHER_SIZE],
           asset_plain[MAX_ASSET_PLAIN_SIZE], key[KEY_SIZE];

  double t1 = wallClock();

  feedOblivCharArray(expected_asset_cipher,
    args->asset_cipher, asset_cipher_size, BUYER);
  feedOblivCharArray(asset_plain, args->asset_plain, asset_plain_size, SELLER);
  feedOblivCharArray(key, args->key, KEY_SIZE, SELLER);

  obliv size_t pad_len = -asset_plain_size % AES_BLOCK_SIZE;
  for (size_t i = 0; i < AES_BLOCK_SIZE; ++i) {
    // there is no `obliv for` so we can't put pad_len in `for` condition
    obliv if (i < pad_len) {
      asset_plain[asset_plain_size + i] = '\0';
    }
  }
  // replaces asset_plain with cipher
  for (size_t i = 0; i < asset_plain_size; i += AES_BLOCK_SIZE) {
    aes_encrypt(asset_plain + i, key);
  }
  obliv bool equal = true;
  for (size_t i = 0; i < asset_cipher_size; ++i) {
    obliv if (expected_asset_cipher[i] != asset_plain[i]) {
      equal = false;
    }
  }

  // TODO: find faster way to reveal secret
  // and use user-defined secret
  obl_char secret[SECRET_SIZE];
  obliv if (equal) {
    for (int i = 0; i < SECRET_SIZE; ++i) {
      secret[i] = good_secret[i];
    }
  } else {
    for (int i = 0; i < SECRET_SIZE; ++i) {
      secret[i] = bad_secret[i];
    }
  }
  revealOblivCharArray(&args->secret, secret, SECRET_SIZE, SELLER);

  double t2 = wallClock() - t1;

  /* Run by Seller right after running GC - Last (definitely with sha256; out of circuit)
   * - args->secret is GC output
   * - args->secret_hash has been sent by Buyer
   *
   * assert(!strcmp(secret_hash(args->secret), args->secret_hash));
   */

  /* Run in GC - translate SHA256 to obliv-c (maybe with pedersen commitment for speed)
   * - args->asset_plain is GC input
   * - args->asset_hash is public information
   *
   * assert(!strcmp(asset_hash(args->asset_plain), args->asset_hash));
   */

  /* Run in GC - translate SHA256 to obliv-c (definitely with sha256; must be doable onchain)
   * - args->key is GC input
   * - args->key_hash is hardcoded in GC
   *   (Buyer hardcodes it after receiving from Seller)
   * assert(!strcmp(sha256(args->key), args->key_hash));
   */

  printf("time: %f\n", t2);
}
